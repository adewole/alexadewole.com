<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Replays in Minecraft - Alex Adewole</title><meta name="gridsome:hash" content="2cce40fa7bcd1bfdf0c7778da829c849f909be31"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.19"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/assets/static/favicon.62d22cb.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/assets/static/favicon.1539b60.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/assets/static/favicon.dc0cdc5.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/assets/static/favicon.7b22250.9bb7ffafafc09ac851d81afb65b8ef59.png"><link rel="preload" href="/assets/css/6.styles.5f83fa14.css" as="style"><link rel="preload" href="/assets/js/app.a3b0e01e.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--post-vue.c2a91328.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules--gridsome--app--pages--404-vue.90c8aebb.js"><link rel="prefetch" href="/assets/js/page--src--pages--blog-vue.59da31ba.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.9be217ee.js"><link rel="prefetch" href="/assets/js/page--src--pages--resume-vue.423de9cd.js"><link rel="stylesheet" href="/assets/css/6.styles.5f83fa14.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <div data-server-rendered="true" id="app" class="w-full flex"><div class="p-4 w-full md:w-2/3 md:m-auto md:px-0 md:pt-40"><main><div class="flex flex-wrap p-5 mb-10 md:mb-40"><div class="m-auto w-full lg:w-10/12"><div class="flex flex-wrap md:justify-center"><div class="text-center leading-snug relative w-full text-gray-700"><a href="/blog"><svg xmlns="http://www.w3.org/2000/svg" viewBox="-6 -6 24 24" width="24" height="24" preserveAspectRatio="xMinYMin" class="jam jam-close absolute md:fixed left-0 top-0 md:m-10 w-12 h-12 fill-current opacity-50 transition duration-300 hover:opacity-75"><path d="M7.314 5.9l3.535-3.536A1 1 0 1 0 9.435.95L5.899 4.485 2.364.95A1 1 0 1 0 .95 2.364l3.535 3.535L.95 9.435a1 1 0 1 0 1.414 1.414l3.535-3.535 3.536 3.535a1 1 0 1 0 1.414-1.414L7.314 5.899z"></path></svg></a><h2 class="text-2xl text-gray-800">Saturday, June 27th, 2020</h2><h1 class="text-4xl text-gray-500 light:text-black">Replays in Minecraft</h1></div><div class="flex w-full justify-center"><div class="prose text-gray-500 light:text-gray-700 mt-5 md:mt-10 w-full"><p>I was recently tasked with creating a system within <a href="https://hub.spigotmc.org/javadocs/spigot/" target="_blank" rel="nofollow noopener noreferrer">Bukkit</a> that would allow players to playback "replays" of their fights.</p>
<p>Before starting on this project, I knew that I needed a medium to actually <em>replay</em> a player's actions. Specifically, I needed something that would allow me to spawn and control my own <a href="https://en.wikipedia.org/wiki/Non-player_character" target="_blank" rel="nofollow noopener noreferrer">NPC</a>'s. </p>
<p>The simplest drop-in library/plugin that would've filled this role is <a href="https://github.com/CitizensDev/Citizens2" target="_blank" rel="nofollow noopener noreferrer">Citizens</a>. Citizens is described as "the premier plugin and API for creating server-side NPCs in Minecraft"</p>
<p>This is <em>mostly</em> true, however, like most public/open-source software -- it's built to encompass a wide array of use-cases, and a large portion of Citizens' features were things we didn't need. </p>
<p><em>I also, kind of, just wanted to make an NPC library...</em></p>
<p>I won't delve too much into how this library works (as this post is specifically about the replay system), but it involved a lot of obfuscated Minecraft server code (NMS). It wrapped all the ugly obfuscated code into a neat OOP API and let me run logic specific to an NPC, <em>such as replaying a player's actions</em>.</p>
<h2 id="recording"><a href="#recording" aria-hidden="true"><span class="icon icon-link"></span></a>Recording</h2>
<p>I recorded a player's actions in two ways: packet interception and event listeners. In retrospect, I <em>could</em> have got away using only event listeners but intercepting packets <em>was</em> a little faster. A recordable player action, <code>ReplayableAction</code> in code, represented a single player-originating action that could be re-enacted on a <code>Bot</code>.</p>
<pre><code class="language-java">/**
 * Represents a recorded player action that can
 * be replayed on a specified {@link Bot} at a later time
 */
public interface ReplayableAction {

    /**
     * Replays the recorded action on the specified bot.
     * @param bot the bot to replay the action on
     */
    void replay(@NotNull Bot bot);

}
</code></pre>
<p>Anything that a player did during a fight that we wanted to record + replay had a corresponding implementation of <code>ReplayableAction</code>. There was one for movement, animations, meta (such as sneaking or sprinting) and more.</p>
<p>Here is an implementation of <code>ReplayableAction</code> for when a player died:</p>
<pre><code class="language-java">public class PlayerDeathEventAction extends ReplayableEventAction&#x3C;PlayerDeathEvent> {

    /**
     * Replayable actions are constructed using a {@link Event} type
     * where values are extrapolated to be used later in {@link #replay(Bot)}
     *
     * @param event an instance of {@link PlayerDeathEvent}
     */
    public PlayerDeathEventAction(PlayerDeathEvent event) {
        super(event);
    }

    @Override
    public void replay(@NotNull Bot bot) {
        bot.setHealth(0);
    }

}
</code></pre>
<p><code>ReplayableAction</code>'s were then grouped together into a frame. This was important because it was possible for a player to commit more than one action in quick succession (&#x3C;100ms). These frames were then mapped to an integer representing a timestamp that was relative to the time the recording started.</p>
<pre><code class="language-rust">// pseudo structure of a recording
recording: {
  0: [player left-clicked, player crouched],
  24: [player uncrouched],
  39: [player started sprinting, player moved to x,y,z],
  90: [player stopped sprinting]
}
</code></pre>
<h2 id="playback"><a href="#playback" aria-hidden="true"><span class="icon icon-link"></span></a>Playback</h2>
<p>Each <code>ReplayableAction</code> exposed a <code>#replay(Bot)</code> function that made playback relatively simple. I created a type that essentially served as a queue against the previously recorded frames. Playback started by spawning an <code>NPC</code> with logic that would poll the frame queue to get a frame. Each time the queue was polled, a timestamp variable, <code>x</code>, would be incremented by 1. <code>x</code> was in the same time space as the mapped frames so the rate of playback matched the rate of recording.</p>
<p>Everytime the <code>Bot</code> logic received a frame, it would iterate over the embedded <code>ReplayableActions</code>'s and invoke the respective <code>#replay(Bot)</code> function.</p>
<p>Because of <code>x</code>, players were also able to skip forward or backwards in time during playback. Introducing a <code>paused:bool</code> variable that would prevent the queue from incrementing <code>x</code> also allowed players to pause.</p>
<blockquote>
<video style="width: 100%; max-height: 100%;" src="https://imgur.com/7D6JmbV.mp4" muted autoplay loop /> 
</blockquote>
<p style="text-align: center;">Skipping forwards, backwards and pausing playback.</p>
<p>That's about everything related to playback. One thing to note, though, is that <strong>each replay is essentially a collection of player-specific recordings</strong>. No recording is dependant on another, so we could play back one player in a fight and see them taking damage from an invisible source -- <em>It's kinda cool</em>.</p>
<blockquote>
<video style="width: 100%; max-height: 100%;" src="https://imgur.com/8T3YvyC.mp4" muted autoplay loop />
</blockquote>
<p style="text-align: center;">A replay consisting of only <strong>one</strong> player in a fight</p>
<h2 id="persisting-replays"><a href="#persisting-replays" aria-hidden="true"><span class="icon icon-link"></span></a>Persisting Replays</h2>
<p>Okay, we've got recording and playback done, but now we need to actually save the replays so they can be played back after the server reboots. </p>
<p>My first instict was to just serialize the recordings to JSON and throw them into <a href="https://www.mongodb.com" target="_blank" rel="nofollow noopener noreferrer">Mongo</a>.</p>
<p>But... replays could consist of <strong>tens of thousands</strong> of frames, and the J/BSON structure introduced a ton of extra bloat that increased the size. On top of that, there was the additional overhead of parsing huge fucking J/BSON<sup><a href="#1">1</a></sup> documents and the extra time of transfering this data.</p>
<p>Our use-case was pretty specific in that we only needed replays to be played back on a single stateful machine/server. This meant that we could consider solutions that only made saved replays accessible <em>locally</em>. </p>
<p>I opted, then, to create a custom <a href="https://en.wikipedia.org/wiki/File_format" target="_blank" rel="nofollow noopener noreferrer">file format</a> specifically for replays and store them on the machine's drive. So, instead of writing/parsing to/from J/BSON, I could write (non UTF) bytes directly to a file. Unfortunately, it also meant that I had to manually write writers and parsers for each <code>ReplayableAction</code>.</p>
<p>I introduced a <code>#write(DataOutputStream)</code> function to the <code>ReplayableAction</code> interface:</p>
<pre><code class="language-java">  /**
    * Writes this action to a ${@linkplain DataOutputStream stream}.
    * @param stream the stream to write to
    * @throws IOException if stream fails to be written to
    */
  void write(@NotNull DataOutputStream stream) throws IOException;
</code></pre>
<p>This made each implemention of <code>ReplayableAction</code> responsible for writing itself to a stream and kept things a little cleaner. After implementing that function for all the action types, I started on the reading stuff. I'll go more into the details of the custom file format's specification in a bit, but specifically for <code>ReplayableActions</code>:</p>
<p>I decided to create an <a href="https://en.wikipedia.org/wiki/Enumerated_type" target="_blank" rel="nofollow noopener noreferrer">Enum</a>{:target="_blank"} with variants bound to a specific <code>ReplayableAction</code> type and a functional type that would use an input stream as context. <em>This also had the added benefit of letting me write a single byte representing an action type (the ordinal of the variant) instead of the fully qualified String name of the class or implementing some other identifieer.</em></p>
<p>The structure of this was more or less like this:</p>
<pre><code class="language-java">public interface Provider&#x3C;T> {
    T get(DataInputStream stream) throws IOException;
}

public enum ReplayableActionType {
  ...
  DAMAGE(stream -> new EntityDamageEventAction(stream.readInt())),

  private Provider&#x3C;? extends ReplayableAction> provider;

  &#x3C;T extends ReplayableAction> ReplayableActionType(Provider&#x3C;T> provider) {
    this.provider = provider;
  }

}
</code></pre>
<p>However, there's still some extra data outside of the <code>ReplayableAction</code>'s that need to be stored. I'm not going to go too much into how they're written/read but I will outline the file format spec:</p>
<blockquote>
<p><em>File Header</em></p>
<table>
<thead>
<tr>
<th>byte count </th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 byte</td>
<td>magic</td>
<td>0xf</td>
</tr>
<tr>
<td>2 bytes</td>
<td>(ushort) length of bytes in replay id      </td>
<td>?</td>
</tr>
<tr>
<td>? bytes</td>
<td>UTF-8 replay id</td>
<td>?</td>
</tr>
</tbody>
</table>
<p><em>File Content</em></p>
<table>
<thead>
<tr>
<th>byte count </th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 byte</td>
<td>(ubyte) number of recordings in this replay </td>
<td>?</td>
</tr>
<tr>
<td>? bytes</td>
<td>\&#x3C;array of recordings> </td>
<td>?</td>
</tr>
</tbody>
</table>
<p><em>Recording Element</em></p>
<table>
<thead>
<tr>
<th>byte count </th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>8 bytes</td>
<td>(ulong) most significant bits of player uuid</td>
<td>?</td>
</tr>
<tr>
<td>8 bytes</td>
<td>(ulong) least significant bits of player uuid </td>
<td>?</td>
</tr>
<tr>
<td>4 bytes</td>
<td>(uint) length of recording (in milliseconds)</td>
<td>?</td>
</tr>
<tr>
<td>4 bytes</td>
<td>(uint) amount of frames in this recording</td>
<td>?</td>
</tr>
<tr>
<td>? bytes</td>
<td>\&#x3C;array of frames></td>
<td>?</td>
</tr>
</tbody>
</table>
<p><em>Frame Element</em></p>
<table>
<thead>
<tr>
<th>byte count </th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>8 bytes</td>
<td>(ulong) timestamp of this frame</td>
<td>?</td>
</tr>
<tr>
<td>4 bytes</td>
<td>(uint) amount of actions in this frame </td>
<td>?</td>
</tr>
<tr>
<td>? bytes</td>
<td>\&#x3C;array of actions></td>
<td>?</td>
</tr>
</tbody>
</table>
<p><em>Action Element</em></p>
<table>
<thead>
<tr>
<th>byte count </th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 byte</td>
<td>ordinal of the enum variant for this action </td>
<td>?</td>
</tr>
<tr>
<td>? bytes</td>
<td>extra data specific to this action type</td>
<td>?</td>
</tr>
</tbody>
</table>
</blockquote>
<h2 id="conclusion"><a href="#conclusion" aria-hidden="true"><span class="icon icon-link"></span></a>Conclusion</h2>
<p>All-in-all this was an extremely fun project to work on. In hindsight there's a couple things I would do differently, like not using packet interception for actions, throwing the binary <code>.replay</code> file in MongoDB, etc. There's one <em>slight</em> caveot with my design though:</p>
<p>Essentially each recorded player is on their own track. Frames are recorded and timestamped relative to when the recorder started. The difference in time (due to server performance or other factors) between starting the recorder for x amount of players in a fight can be enough to offset their tracks so that when they're played back they're out of sync. The solution to this would be to use a metric that isn't relative to each track (such as unix epoch) to find the time difference and re-align all the tracks. I initially implemented the recorders to use unix epoch as the key for frames but having to reindex them and convert to ticks, etc introduced a ton of overhead and wasted computation.</p>
<p>I plan on writing more posts like this. I write a lot of code and I want to look back on this blog five years from now and see how far I've come <em>(or not come)</em>. </p>
<h1 style="opacity: 0; height: 0; margin: 0;" id="1">1</h1>
<small style="opacity: 0.5">1. Yes, I know it's possible to store binary content inside MongoDB. If our requirements were different and we needed replays to be accessible externally then this is what I would've done. Although, in retrospect, I probably should've done this anyways and just run the Mongo server locally, that way we could switch to a remote database in the future (if we wanted/needed to) without any code changes.
</div></div></div></div></div></main></div></div>
    <script>window.__INITIAL_STATE__={"data":{"post":{"title":"Replays in Minecraft","path":"\u002Freplays-in-minecraft\u002F","date":"Saturday, June 27th, 2020","description":"I describe how I designed and implemented player replays in the scope of a Minecraft server.","content":"\u003Cp\u003EI was recently tasked with creating a system within \u003Ca href=\"https:\u002F\u002Fhub.spigotmc.org\u002Fjavadocs\u002Fspigot\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EBukkit\u003C\u002Fa\u003E that would allow players to playback \"replays\" of their fights.\u003C\u002Fp\u003E\n\u003Cp\u003EBefore starting on this project, I knew that I needed a medium to actually \u003Cem\u003Ereplay\u003C\u002Fem\u003E a player's actions. Specifically, I needed something that would allow me to spawn and control my own \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FNon-player_character\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ENPC\u003C\u002Fa\u003E's. \u003C\u002Fp\u003E\n\u003Cp\u003EThe simplest drop-in library\u002Fplugin that would've filled this role is \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FCitizensDev\u002FCitizens2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ECitizens\u003C\u002Fa\u003E. Citizens is described as \"the premier plugin and API for creating server-side NPCs in Minecraft\"\u003C\u002Fp\u003E\n\u003Cp\u003EThis is \u003Cem\u003Emostly\u003C\u002Fem\u003E true, however, like most public\u002Fopen-source software -- it's built to encompass a wide array of use-cases, and a large portion of Citizens' features were things we didn't need. \u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cem\u003EI also, kind of, just wanted to make an NPC library...\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EI won't delve too much into how this library works (as this post is specifically about the replay system), but it involved a lot of obfuscated Minecraft server code (NMS). It wrapped all the ugly obfuscated code into a neat OOP API and let me run logic specific to an NPC, \u003Cem\u003Esuch as replaying a player's actions\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\n\u003Ch2 id=\"recording\"\u003E\u003Ca href=\"#recording\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ERecording\u003C\u002Fh2\u003E\n\u003Cp\u003EI recorded a player's actions in two ways: packet interception and event listeners. In retrospect, I \u003Cem\u003Ecould\u003C\u002Fem\u003E have got away using only event listeners but intercepting packets \u003Cem\u003Ewas\u003C\u002Fem\u003E a little faster. A recordable player action, \u003Ccode\u003EReplayableAction\u003C\u002Fcode\u003E in code, represented a single player-originating action that could be re-enacted on a \u003Ccode\u003EBot\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-java\"\u003E\u002F**\n * Represents a recorded player action that can\n * be replayed on a specified {@link Bot} at a later time\n *\u002F\npublic interface ReplayableAction {\n\n    \u002F**\n     * Replays the recorded action on the specified bot.\n     * @param bot the bot to replay the action on\n     *\u002F\n    void replay(@NotNull Bot bot);\n\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EAnything that a player did during a fight that we wanted to record + replay had a corresponding implementation of \u003Ccode\u003EReplayableAction\u003C\u002Fcode\u003E. There was one for movement, animations, meta (such as sneaking or sprinting) and more.\u003C\u002Fp\u003E\n\u003Cp\u003EHere is an implementation of \u003Ccode\u003EReplayableAction\u003C\u002Fcode\u003E for when a player died:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-java\"\u003Epublic class PlayerDeathEventAction extends ReplayableEventAction&#x3C;PlayerDeathEvent\u003E {\n\n    \u002F**\n     * Replayable actions are constructed using a {@link Event} type\n     * where values are extrapolated to be used later in {@link #replay(Bot)}\n     *\n     * @param event an instance of {@link PlayerDeathEvent}\n     *\u002F\n    public PlayerDeathEventAction(PlayerDeathEvent event) {\n        super(event);\n    }\n\n    @Override\n    public void replay(@NotNull Bot bot) {\n        bot.setHealth(0);\n    }\n\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003EReplayableAction\u003C\u002Fcode\u003E's were then grouped together into a frame. This was important because it was possible for a player to commit more than one action in quick succession (&#x3C;100ms). These frames were then mapped to an integer representing a timestamp that was relative to the time the recording started.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-rust\"\u003E\u002F\u002F pseudo structure of a recording\nrecording: {\n  0: [player left-clicked, player crouched],\n  24: [player uncrouched],\n  39: [player started sprinting, player moved to x,y,z],\n  90: [player stopped sprinting]\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"playback\"\u003E\u003Ca href=\"#playback\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EPlayback\u003C\u002Fh2\u003E\n\u003Cp\u003EEach \u003Ccode\u003EReplayableAction\u003C\u002Fcode\u003E exposed a \u003Ccode\u003E#replay(Bot)\u003C\u002Fcode\u003E function that made playback relatively simple. I created a type that essentially served as a queue against the previously recorded frames. Playback started by spawning an \u003Ccode\u003ENPC\u003C\u002Fcode\u003E with logic that would poll the frame queue to get a frame. Each time the queue was polled, a timestamp variable, \u003Ccode\u003Ex\u003C\u002Fcode\u003E, would be incremented by 1. \u003Ccode\u003Ex\u003C\u002Fcode\u003E was in the same time space as the mapped frames so the rate of playback matched the rate of recording.\u003C\u002Fp\u003E\n\u003Cp\u003EEverytime the \u003Ccode\u003EBot\u003C\u002Fcode\u003E logic received a frame, it would iterate over the embedded \u003Ccode\u003EReplayableActions\u003C\u002Fcode\u003E's and invoke the respective \u003Ccode\u003E#replay(Bot)\u003C\u002Fcode\u003E function.\u003C\u002Fp\u003E\n\u003Cp\u003EBecause of \u003Ccode\u003Ex\u003C\u002Fcode\u003E, players were also able to skip forward or backwards in time during playback. Introducing a \u003Ccode\u003Epaused:bool\u003C\u002Fcode\u003E variable that would prevent the queue from incrementing \u003Ccode\u003Ex\u003C\u002Fcode\u003E also allowed players to pause.\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cvideo style=\"width: 100%; max-height: 100%;\" src=\"https:\u002F\u002Fimgur.com\u002F7D6JmbV.mp4\" muted autoplay loop \u002F\u003E \n\u003C\u002Fblockquote\u003E\n\u003Cp style=\"text-align: center;\"\u003ESkipping forwards, backwards and pausing playback.\u003C\u002Fp\u003E\n\u003Cp\u003EThat's about everything related to playback. One thing to note, though, is that \u003Cstrong\u003Eeach replay is essentially a collection of player-specific recordings\u003C\u002Fstrong\u003E. No recording is dependant on another, so we could play back one player in a fight and see them taking damage from an invisible source -- \u003Cem\u003EIt's kinda cool\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cvideo style=\"width: 100%; max-height: 100%;\" src=\"https:\u002F\u002Fimgur.com\u002F8T3YvyC.mp4\" muted autoplay loop \u002F\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp style=\"text-align: center;\"\u003EA replay consisting of only \u003Cstrong\u003Eone\u003C\u002Fstrong\u003E player in a fight\u003C\u002Fp\u003E\n\u003Ch2 id=\"persisting-replays\"\u003E\u003Ca href=\"#persisting-replays\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EPersisting Replays\u003C\u002Fh2\u003E\n\u003Cp\u003EOkay, we've got recording and playback done, but now we need to actually save the replays so they can be played back after the server reboots. \u003C\u002Fp\u003E\n\u003Cp\u003EMy first instict was to just serialize the recordings to JSON and throw them into \u003Ca href=\"https:\u002F\u002Fwww.mongodb.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EMongo\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003EBut... replays could consist of \u003Cstrong\u003Etens of thousands\u003C\u002Fstrong\u003E of frames, and the J\u002FBSON structure introduced a ton of extra bloat that increased the size. On top of that, there was the additional overhead of parsing huge fucking J\u002FBSON\u003Csup\u003E\u003Ca href=\"#1\"\u003E1\u003C\u002Fa\u003E\u003C\u002Fsup\u003E documents and the extra time of transfering this data.\u003C\u002Fp\u003E\n\u003Cp\u003EOur use-case was pretty specific in that we only needed replays to be played back on a single stateful machine\u002Fserver. This meant that we could consider solutions that only made saved replays accessible \u003Cem\u003Elocally\u003C\u002Fem\u003E. \u003C\u002Fp\u003E\n\u003Cp\u003EI opted, then, to create a custom \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FFile_format\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Efile format\u003C\u002Fa\u003E specifically for replays and store them on the machine's drive. So, instead of writing\u002Fparsing to\u002Ffrom J\u002FBSON, I could write (non UTF) bytes directly to a file. Unfortunately, it also meant that I had to manually write writers and parsers for each \u003Ccode\u003EReplayableAction\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003EI introduced a \u003Ccode\u003E#write(DataOutputStream)\u003C\u002Fcode\u003E function to the \u003Ccode\u003EReplayableAction\u003C\u002Fcode\u003E interface:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-java\"\u003E  \u002F**\n    * Writes this action to a ${@linkplain DataOutputStream stream}.\n    * @param stream the stream to write to\n    * @throws IOException if stream fails to be written to\n    *\u002F\n  void write(@NotNull DataOutputStream stream) throws IOException;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThis made each implemention of \u003Ccode\u003EReplayableAction\u003C\u002Fcode\u003E responsible for writing itself to a stream and kept things a little cleaner. After implementing that function for all the action types, I started on the reading stuff. I'll go more into the details of the custom file format's specification in a bit, but specifically for \u003Ccode\u003EReplayableActions\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\n\u003Cp\u003EI decided to create an \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FEnumerated_type\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EEnum\u003C\u002Fa\u003E{:target=\"_blank\"} with variants bound to a specific \u003Ccode\u003EReplayableAction\u003C\u002Fcode\u003E type and a functional type that would use an input stream as context. \u003Cem\u003EThis also had the added benefit of letting me write a single byte representing an action type (the ordinal of the variant) instead of the fully qualified String name of the class or implementing some other identifieer.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EThe structure of this was more or less like this:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-java\"\u003Epublic interface Provider&#x3C;T\u003E {\n    T get(DataInputStream stream) throws IOException;\n}\n\npublic enum ReplayableActionType {\n  ...\n  DAMAGE(stream -\u003E new EntityDamageEventAction(stream.readInt())),\n\n  private Provider&#x3C;? extends ReplayableAction\u003E provider;\n\n  &#x3C;T extends ReplayableAction\u003E ReplayableActionType(Provider&#x3C;T\u003E provider) {\n    this.provider = provider;\n  }\n\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EHowever, there's still some extra data outside of the \u003Ccode\u003EReplayableAction\u003C\u002Fcode\u003E's that need to be stored. I'm not going to go too much into how they're written\u002Fread but I will outline the file format spec:\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cem\u003EFile Header\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003Ebyte count \u003C\u002Fth\u003E\n\u003Cth\u003Edescription\u003C\u002Fth\u003E\n\u003Cth\u003Evalue\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E1 byte\u003C\u002Ftd\u003E\n\u003Ctd\u003Emagic\u003C\u002Ftd\u003E\n\u003Ctd\u003E0xf\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E2 bytes\u003C\u002Ftd\u003E\n\u003Ctd\u003E(ushort) length of bytes in replay id      \u003C\u002Ftd\u003E\n\u003Ctd\u003E?\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E? bytes\u003C\u002Ftd\u003E\n\u003Ctd\u003EUTF-8 replay id\u003C\u002Ftd\u003E\n\u003Ctd\u003E?\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\n\u003C\u002Ftable\u003E\n\u003Cp\u003E\u003Cem\u003EFile Content\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003Ebyte count \u003C\u002Fth\u003E\n\u003Cth\u003Edescription\u003C\u002Fth\u003E\n\u003Cth\u003Evalue\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E1 byte\u003C\u002Ftd\u003E\n\u003Ctd\u003E(ubyte) number of recordings in this replay \u003C\u002Ftd\u003E\n\u003Ctd\u003E?\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E? bytes\u003C\u002Ftd\u003E\n\u003Ctd\u003E\\&#x3C;array of recordings\u003E \u003C\u002Ftd\u003E\n\u003Ctd\u003E?\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\n\u003C\u002Ftable\u003E\n\u003Cp\u003E\u003Cem\u003ERecording Element\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003Ebyte count \u003C\u002Fth\u003E\n\u003Cth\u003Edescription\u003C\u002Fth\u003E\n\u003Cth\u003Evalue\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E8 bytes\u003C\u002Ftd\u003E\n\u003Ctd\u003E(ulong) most significant bits of player uuid\u003C\u002Ftd\u003E\n\u003Ctd\u003E?\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E8 bytes\u003C\u002Ftd\u003E\n\u003Ctd\u003E(ulong) least significant bits of player uuid \u003C\u002Ftd\u003E\n\u003Ctd\u003E?\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E4 bytes\u003C\u002Ftd\u003E\n\u003Ctd\u003E(uint) length of recording (in milliseconds)\u003C\u002Ftd\u003E\n\u003Ctd\u003E?\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E4 bytes\u003C\u002Ftd\u003E\n\u003Ctd\u003E(uint) amount of frames in this recording\u003C\u002Ftd\u003E\n\u003Ctd\u003E?\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E? bytes\u003C\u002Ftd\u003E\n\u003Ctd\u003E\\&#x3C;array of frames\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E?\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\n\u003C\u002Ftable\u003E\n\u003Cp\u003E\u003Cem\u003EFrame Element\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003Ebyte count \u003C\u002Fth\u003E\n\u003Cth\u003Edescription\u003C\u002Fth\u003E\n\u003Cth\u003Evalue\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E8 bytes\u003C\u002Ftd\u003E\n\u003Ctd\u003E(ulong) timestamp of this frame\u003C\u002Ftd\u003E\n\u003Ctd\u003E?\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E4 bytes\u003C\u002Ftd\u003E\n\u003Ctd\u003E(uint) amount of actions in this frame \u003C\u002Ftd\u003E\n\u003Ctd\u003E?\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E? bytes\u003C\u002Ftd\u003E\n\u003Ctd\u003E\\&#x3C;array of actions\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E?\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\n\u003C\u002Ftable\u003E\n\u003Cp\u003E\u003Cem\u003EAction Element\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003Ebyte count \u003C\u002Fth\u003E\n\u003Cth\u003Edescription\u003C\u002Fth\u003E\n\u003Cth\u003Evalue\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E1 byte\u003C\u002Ftd\u003E\n\u003Ctd\u003Eordinal of the enum variant for this action \u003C\u002Ftd\u003E\n\u003Ctd\u003E?\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E? bytes\u003C\u002Ftd\u003E\n\u003Ctd\u003Eextra data specific to this action type\u003C\u002Ftd\u003E\n\u003Ctd\u003E?\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\n\u003C\u002Ftable\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"conclusion\"\u003E\u003Ca href=\"#conclusion\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EConclusion\u003C\u002Fh2\u003E\n\u003Cp\u003EAll-in-all this was an extremely fun project to work on. In hindsight there's a couple things I would do differently, like not using packet interception for actions, throwing the binary \u003Ccode\u003E.replay\u003C\u002Fcode\u003E file in MongoDB, etc. There's one \u003Cem\u003Eslight\u003C\u002Fem\u003E caveot with my design though:\u003C\u002Fp\u003E\n\u003Cp\u003EEssentially each recorded player is on their own track. Frames are recorded and timestamped relative to when the recorder started. The difference in time (due to server performance or other factors) between starting the recorder for x amount of players in a fight can be enough to offset their tracks so that when they're played back they're out of sync. The solution to this would be to use a metric that isn't relative to each track (such as unix epoch) to find the time difference and re-align all the tracks. I initially implemented the recorders to use unix epoch as the key for frames but having to reindex them and convert to ticks, etc introduced a ton of overhead and wasted computation.\u003C\u002Fp\u003E\n\u003Cp\u003EI plan on writing more posts like this. I write a lot of code and I want to look back on this blog five years from now and see how far I've come \u003Cem\u003E(or not come)\u003C\u002Fem\u003E. \u003C\u002Fp\u003E\n\u003Ch1 style=\"opacity: 0; height: 0; margin: 0;\" id=\"1\"\u003E1\u003C\u002Fh1\u003E\n\u003Csmall style=\"opacity: 0.5\"\u003E1. Yes, I know it's possible to store binary content inside MongoDB. If our requirements were different and we needed replays to be accessible externally then this is what I would've done. Although, in retrospect, I probably should've done this anyways and just run the Mongo server locally, that way we could switch to a remote database in the future (if we wanted\u002Fneeded to) without any code changes.\n"}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.a3b0e01e.js" defer></script><script src="/assets/js/page--src--templates--post-vue.c2a91328.js" defer></script>
  </body>
</html>
